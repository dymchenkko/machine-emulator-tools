/* automatically generated by rust-bindgen 0.69.2 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 37;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " A slice of contiguous memory from @b begin to @b end, as an open range.\n Size can be taken with: `end - begin`.\n\n `begin == end` indicate an empty buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmt_buf_t {
    #[doc = "< begin of memory region"]
    pub begin: *mut u8,
    #[doc = "< end of memory region"]
    pub end: *mut u8,
}
#[test]
fn bindgen_test_layout_cmt_buf_t() {
    const UNINIT: ::std::mem::MaybeUninit<cmt_buf_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmt_buf_t>(),
        16usize,
        concat!("Size of: ", stringify!(cmt_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cmt_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cmt_buf_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).begin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_buf_t),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_buf_t),
            "::",
            stringify!(end)
        )
    );
}
extern "C" {
    #[doc = " Initialize @p me buffer backed by @p data, @p length bytes in size\n\n @param [out] me     a uninitialized instance\n @param [in]  length size in bytes of @b data\n @param [in]  data   the backing memory to be used.\n\n @note @p data memory must outlive @p me.\n user must copy the contents otherwise"]
    pub fn cmt_buf_init(me: *mut cmt_buf_t, length: usize, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Split a buffer in two, @b lhs with @b lhs_length bytes and @b rhs with the rest\n\n @param [in,out] me         initialized buffer\n @param [in]     lhs_length bytes in @b lhs\n @param [out]    lhs        left hand side\n @param [out]    rhs        right hand side\n\n @return\n - 0 success\n - negative value on error. -ENOBUFS when length(me) < lhs_length."]
    pub fn cmt_buf_split(
        me: *const cmt_buf_t,
        lhs_length: usize,
        lhs: *mut cmt_buf_t,
        rhs: *mut cmt_buf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Length in bytes of @p me\n\n @param [in] me     initialized buffer\n\n @return\n - size in bytes"]
    pub fn cmt_buf_length(me: *const cmt_buf_t) -> usize;
}
extern "C" {
    #[doc = " Print the contents of @b me buffer to stdout\n\n @param [in] begin          start of memory region\n @param [in] end            end of memory region\n @param [in] bytes_per_line bytes per line (must be a power of 2)."]
    pub fn cmt_buf_xxd(
        begin: *mut ::std::os::raw::c_void,
        end: *mut ::std::os::raw::c_void,
        bytes_per_line: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Take the substring @p x from @p xs start to the first @p , (comma).\n @param [out]    x           substring\n @param [in,out] xs          string (interator)\n\n @note @p x points inside @p xs, make a copy if it outlives @p xs."]
    pub fn cmt_buf_split_by_comma(x: *mut cmt_buf_t, xs: *mut cmt_buf_t) -> bool;
}
#[doc = "< length of a evm word in bytes"]
pub const CMT_WORD_LENGTH: _bindgen_ty_1 = 32;
#[doc = "< length of a evm address in bytes"]
pub const CMT_ADDRESS_LENGTH: _bindgen_ty_1 = 20;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Create a function selector from an array of bytes\n @param [in] funsel function selector bytes\n @return\n - function selector converted to big endian (as expected by EVM)"]
    pub fn cmt_abi_funsel(a: u8, b: u8, c: u8, d: u8) -> u32;
}
extern "C" {
    #[doc = " Encode a function selector into the buffer @p me\n\n @param [in,out] me     a initialized buffer working as iterator\n @param [in]     funsel function selector\n\n @return\n - 0 success\n - ENOBUFS no space left in @p me\n\n @note A function selector can be compute it with: @ref cmt_keccak_funsel.\n It is always represented in big endian."]
    pub fn cmt_abi_put_funsel(me: *mut cmt_buf_t, funsel: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encode a unsigned integer of up to 32bytes of data into the buffer\n\n @param [in,out] me   a initialized buffer working as iterator\n @param [in]     n    size of @p data in bytes\n @param [in]     data poiter to a integer\n\n @return\n - 0 success\n - ENOBUFS no space left in @p me\n - EDOM requested @p n is too large\n\n @code\n ...\n cmt_buf_t it = ...;\n uint64_t x = UINT64_C(0xdeadbeef);\n cmt_abi_put_uint(&it, sizeof x, &x);\n ...\n @endcode\n @note This function takes care of endianess conversions"]
    pub fn cmt_abi_put_uint(
        me: *mut cmt_buf_t,
        n: usize,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encode a big-endian value of up to 32bytes of data into the buffer\n\n @param [in,out] me     a initialized buffer working as iterator\n @param [in]     length size of @p data in bytes\n @param [in]     data   poiter to a integer\n\n @return\n - 0 success\n - ENOBUFS no space left in @p me\n - EDOM requested @p n is too large\n\n @code\n ...\n cmt_buf_t it = ...;\n uint8_t small[] = {\n     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n };\n cmt_abi_put_uint(&it, sizeof small, &small);\n ...\n uint8_t big[] = {\n     0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n };\n cmt_abi_put_uint(&it, sizeof big, &big);\n @endcode\n @note This function takes care of endianess conversions"]
    pub fn cmt_abi_put_uint_be(
        me: *mut cmt_buf_t,
        n: usize,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encode a bool into the buffer\n\n @param [in,out] me    a initialized buffer working as iterator\n @param [in]     value boolean value\n\n @return\n - 0 success\n - ENOBUFS no space left in @p me\n\n @code\n ...\n cmt_buf_t it = ...;\n cmt_abi_put_bool(&it, true);\n ...\n @endcode\n @note This function takes care of endianess conversions"]
    pub fn cmt_abi_put_bool(me: *mut cmt_buf_t, value: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encode @p address (exacly @ref CMT_ADDRESS_LENGTH bytes) into the buffer\n\n @param [in,out] me      initialized buffer\n @param [in]     address exactly @ref CMT_ADDRESS_LENGTH bytes\n\n @return\n - 0 success\n - ENOBUFS no space left in @p me"]
    pub fn cmt_abi_put_address(me: *mut cmt_buf_t, address: *const u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encode the static part of @b bytes into the message,\n used in conjunction with @ref cmt_abi_put_bytes_d\n\n @param [in,out] me     initialized buffer\n @param [out]    offset initialize for @ref cmt_abi_put_bytes_d\n @return\n - 0 success\n - ENOBUFS no space left in @p me"]
    pub fn cmt_abi_put_bytes_s(me: *mut cmt_buf_t, offset: *mut cmt_buf_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encode the dynamic part of @b bytes into the message,\n used in conjunction with @ref cmt_abi_put_bytes_d\n\n @param [in,out] me     initialized buffer\n @param [in]     offset initialized from @ref cmt_abi_put_bytes_h\n @param [in]     n      size of @b data\n @param [in]     data   array of bytes\n @param [in]     start  starting point for offset calculation (first byte after funsel)\n @return\n - 0 success\n - ENOBUFS no space left in @p me"]
    pub fn cmt_abi_put_bytes_d(
        me: *mut cmt_buf_t,
        offset: *mut cmt_buf_t,
        n: usize,
        data: *const ::std::os::raw::c_void,
        start: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reserve @b n bytes of data from the buffer into @b res to be filled by the\n caller\n\n @param [in,out] me     initialized buffer\n @param [in]     n      amount of bytes to reserve\n @param [out]    res    slice of bytes extracted from @p me\n @param [in]     start  starting point for offset calculation (first byte after funsel)\n @return\n - 0 success\n - ENOBUFS no space left in @p me\n\n @note @p me must outlive @p res.\n Create a duplicate otherwise"]
    pub fn cmt_abi_reserve_bytes_d(
        me: *mut cmt_buf_t,
        of: *mut cmt_buf_t,
        n: usize,
        out: *mut cmt_buf_t,
        start: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read the funsel without consuming it from the buffer @p me\n\n @param [in]     me     initialized buffer\n @return\n - The function selector\n\n @code\n ...\n if (cmt_buf_length(it) < 4)\n \treturn EXIT_FAILURE;\n switch (cmt_abi_peek_funsel(it) {\n case CMT_ABI_FUNSEL(...): // known type, try to parse it\n case CMT_ABI_FUNSEL(...): // known type, try to parse it\n default:\n \treturn EXIT_FAILURE;\n }\n @endcode\n\n @note user must ensure there are at least 4 bytes in the buffer.\n This function will fail and return 0 if that is not the case."]
    pub fn cmt_abi_peek_funsel(me: *mut cmt_buf_t) -> u32;
}
extern "C" {
    #[doc = " Consume funsel from the buffer @p me and ensure it matches @p expected_funsel\n\n @param [in,out] me       initialized buffer\n @param [in]     expected expected function selector\n\n @return\n - 0 success\n - ENOBUFS no space left in @p me\n - EBADMSG in case of a missmatch"]
    pub fn cmt_abi_check_funsel(me: *mut cmt_buf_t, expected: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode a unsigned integer of up to 32bytes from the buffer\n\n @param [in,out] me     initialized buffer\n @param [in]     n      size of @p data in bytes\n @param [out]    data   pointer to a integer\n\n @return\n - 0 success\n - ENOBUFS no space left in @p me\n - EDOM    value won't fit into @p n bytes."]
    pub fn cmt_abi_get_uint(
        me: *mut cmt_buf_t,
        n: usize,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode @p length big-endian bytes, up to 32, from the buffer into @p data\n\n @param [in,out] me     initialized buffer\n @param [in]     length size of @p data in bytes\n @param [out]    data   pointer to a integer\n\n @return\n - 0 success\n - ENOBUFS no space left in @p me\n - EDOM    value won't fit into @p n bytes."]
    pub fn cmt_abi_get_uint_be(
        me: *mut cmt_buf_t,
        n: usize,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Consume and decode @b address from the buffer\n\n @param [in,out] me      initialized buffer\n @param [out]    address exactly 20 bytes\n\n @return\n - 0 success\n - ENOBUFS requested size @b n is not available"]
    pub fn cmt_abi_get_address(me: *mut cmt_buf_t, address: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Consume and decode the offset @p of\n\n @param [in,out] me initialized buffer\n @param [out]    of offset to @p bytes data, for use in conjunction with @ref cmt_abi_get_bytes_d\n @return\n - 0 success\n - ENOBUFS no space left in @p me"]
    pub fn cmt_abi_get_bytes_s(me: *mut cmt_buf_t, of: *mut cmt_buf_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode @b bytes from the buffer by taking a pointer to its contents.\n\n @param [in]  start initialized buffer (from the start after funsel)\n @param [out]    of    offset to @p bytes data\n @param [out]    n     amount of data available in @b bytes\n @param [out]    bytes memory range with contents\n @return\n - 0 success\n - ENOBUFS no space left in @p me\n @note @p of can be initialized by calling @ref cmt_abi_get_bytes_s"]
    pub fn cmt_abi_get_bytes_d(
        start: *const cmt_buf_t,
        of: *mut cmt_buf_t,
        n: *mut usize,
        bytes: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode @b bytes from the buffer by taking a pointer to its contents.\n\n @param [in]  start initialized buffer (from the start after funsel)\n @param [out] of    offset to @p bytes data\n @param [out] n     amount of data available in @b bytes\n @param [out] bytes memory range with contents\n @return\n - 0 success\n - ENOBUFS no space left in @p me\n @note @p of can be initialized by calling @ref cmt_abi_get_bytes_s"]
    pub fn cmt_abi_peek_bytes_d(
        start: *const cmt_buf_t,
        of: *mut cmt_buf_t,
        bytes: *mut cmt_buf_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encode @p n bytes of @p data into @p out (up to 32).\n\n @param [in]  n    size of @p data in bytes\n @param [in]  data integer value to encode into @p out\n @param [out] out  encoded result\n @return\n - 0    success\n - EDOM @p n is too large."]
    pub fn cmt_abi_encode_uint(
        n: usize,
        data: *const ::std::os::raw::c_void,
        out: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encode @p n bytes of @p data into @p out (up to 32) in reverse order.\n\n @param [in]  n    size of @p data in bytes\n @param [in]  data integer value to encode into @p out\n @param [out] out  encoded result\n @return\n - 0    success\n - EDOM @p n is too large.\n @note use @ref cmt_abi_encode_uint instead"]
    pub fn cmt_abi_encode_uint_nr(n: usize, data: *const u8, out: *mut u8)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encode @p n bytes of @p data into @p out (up to 32) in normal order.\n\n @param [in]  n    size of @p data in bytes\n @param [in]  data integer value to encode into @p out\n @param [out] out  encoded result\n @return\n - 0    success\n - EDOM @p n is too large.\n @note use @ref cmt_abi_encode_uint instead"]
    pub fn cmt_abi_encode_uint_nn(n: usize, data: *const u8, out: *mut u8)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode @p n bytes of @p data into @p out (up to 32).\n\n @param [in]  data integer value to decode into @p out\n @param [in]  n    size of @p data in bytes\n @param [out] out  decoded output"]
    pub fn cmt_abi_decode_uint(data: *const u8, n: usize, out: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode @p n bytes of @p data into @p out (up to 32) in reverse order.\n\n @param [in]  data integer value to decode into @p out\n @param [in]  n    size of @p data in bytes\n @param [out] out  decoded output\n @note if in doubt, use @ref cmt_abi_decode_uint"]
    pub fn cmt_abi_decode_uint_nr(data: *const u8, n: usize, out: *mut u8)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode @p n bytes of @p data into @p out (up to 32) in normal order.\n\n @param [in]  data integer value to decode into @p out\n @param [in]  n    size of @p data in bytes\n @param [out] out  decoded output\n @note if in doubt, use @ref cmt_abi_decode_uint"]
    pub fn cmt_abi_decode_uint_nn(data: *const u8, n: usize, out: *mut u8)
        -> ::std::os::raw::c_int;
}
#[doc = "< IO Device"]
pub const CMT_IO_DEV: _bindgen_ty_2 = 2;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[doc = "< Automatic"]
pub const CMT_IO_CMD_AUTOMATIC: _bindgen_ty_3 = 0;
#[doc = "< Manual"]
pub const CMT_IO_CMD_MANUAL: _bindgen_ty_3 = 1;
#[doc = " Request"]
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
#[doc = "< Progress"]
pub const CMT_IO_REASON_PROGRESS: _bindgen_ty_4 = 0;
#[doc = "< Accept and load next input"]
pub const CMT_IO_REASON_RX_ACCEPTED: _bindgen_ty_4 = 1;
#[doc = "< Reject and revert"]
pub const CMT_IO_REASON_RX_REJECTED: _bindgen_ty_4 = 2;
#[doc = "< emit an output"]
pub const CMT_IO_REASON_TX_OUTPUT: _bindgen_ty_4 = 3;
#[doc = "< emit a report"]
pub const CMT_IO_REASON_TX_REPORT: _bindgen_ty_4 = 4;
#[doc = "< emit a exception and halt execution"]
pub const CMT_IO_REASON_TX_EXCEPTION: _bindgen_ty_4 = 5;
#[doc = " Request"]
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
#[doc = "< Input is advance"]
pub const CMT_IO_REASON_ADVANCE: _bindgen_ty_5 = 0;
#[doc = "< Input is inspect"]
pub const CMT_IO_REASON_INSPECT: _bindgen_ty_5 = 1;
#[doc = " Reply reason when requesting @ref CMT_IO_REASON_RX_ACCEPTED"]
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmt_io_driver_ioctl_t {
    pub tx: [cmt_buf_t; 1usize],
    pub rx: [cmt_buf_t; 1usize],
    pub fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cmt_io_driver_ioctl_t() {
    const UNINIT: ::std::mem::MaybeUninit<cmt_io_driver_ioctl_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmt_io_driver_ioctl_t>(),
        40usize,
        concat!("Size of: ", stringify!(cmt_io_driver_ioctl_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cmt_io_driver_ioctl_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cmt_io_driver_ioctl_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_io_driver_ioctl_t),
            "::",
            stringify!(tx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_io_driver_ioctl_t),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_io_driver_ioctl_t),
            "::",
            stringify!(fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmt_io_driver_mock_t {
    pub tx: [cmt_buf_t; 1usize],
    pub rx: [cmt_buf_t; 1usize],
    pub inputs_left: cmt_buf_t,
    pub input_type: ::std::os::raw::c_int,
    pub input_filename: [::std::os::raw::c_char; 128usize],
    pub input_fileext: [::std::os::raw::c_char; 16usize],
    pub input_seq: ::std::os::raw::c_int,
    pub output_seq: ::std::os::raw::c_int,
    pub report_seq: ::std::os::raw::c_int,
    pub exception_seq: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cmt_io_driver_mock_t() {
    const UNINIT: ::std::mem::MaybeUninit<cmt_io_driver_mock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmt_io_driver_mock_t>(),
        216usize,
        concat!("Size of: ", stringify!(cmt_io_driver_mock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cmt_io_driver_mock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cmt_io_driver_mock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_io_driver_mock_t),
            "::",
            stringify!(tx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_io_driver_mock_t),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputs_left) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_io_driver_mock_t),
            "::",
            stringify!(inputs_left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_type) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_io_driver_mock_t),
            "::",
            stringify!(input_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_filename) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_io_driver_mock_t),
            "::",
            stringify!(input_filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_fileext) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_io_driver_mock_t),
            "::",
            stringify!(input_fileext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_seq) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_io_driver_mock_t),
            "::",
            stringify!(input_seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_seq) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_io_driver_mock_t),
            "::",
            stringify!(output_seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).report_seq) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_io_driver_mock_t),
            "::",
            stringify!(report_seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exception_seq) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_io_driver_mock_t),
            "::",
            stringify!(exception_seq)
        )
    );
}
#[doc = " Implementation specific cmio state."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union cmt_io_driver {
    pub ioctl: cmt_io_driver_ioctl_t,
    pub mock: cmt_io_driver_mock_t,
}
#[test]
fn bindgen_test_layout_cmt_io_driver() {
    const UNINIT: ::std::mem::MaybeUninit<cmt_io_driver> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmt_io_driver>(),
        216usize,
        concat!("Size of: ", stringify!(cmt_io_driver))
    );
    assert_eq!(
        ::std::mem::align_of::<cmt_io_driver>(),
        8usize,
        concat!("Alignment of ", stringify!(cmt_io_driver))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ioctl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_io_driver),
            "::",
            stringify!(ioctl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_io_driver),
            "::",
            stringify!(mock)
        )
    );
}
#[doc = " Implementation specific cmio state."]
pub type cmt_io_driver_t = cmt_io_driver;
#[doc = " yield struct cmt_io_yield"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmt_io_yield {
    pub dev: u8,
    pub cmd: u8,
    pub reason: u16,
    pub data: u32,
}
#[test]
fn bindgen_test_layout_cmt_io_yield() {
    const UNINIT: ::std::mem::MaybeUninit<cmt_io_yield> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmt_io_yield>(),
        8usize,
        concat!("Size of: ", stringify!(cmt_io_yield))
    );
    assert_eq!(
        ::std::mem::align_of::<cmt_io_yield>(),
        4usize,
        concat!("Alignment of ", stringify!(cmt_io_yield))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_io_yield),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_io_yield),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_io_yield),
            "::",
            stringify!(reason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_io_yield),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " yield struct cmt_io_yield"]
pub type cmt_io_yield_t = cmt_io_yield;
extern "C" {
    #[doc = " Open the io device and initialize the driver. Release its resources with @ref cmt_io_fini.\n\n @param [in] me A uninitialized @ref cmt_io_driver state\n @returns\n - 0 on success\n - negative errno code on error"]
    pub fn cmt_io_init(me: *mut cmt_io_driver_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release the driver resources and close the io device.\n\n @param [in] me A sucessfuly initialized state by @ref cmt_io_init\n @note usage of @p me after this call is a BUG and will cause undefined behaviour"]
    pub fn cmt_io_fini(me: *mut cmt_io_driver_t);
}
extern "C" {
    #[doc = " Retrieve the transmit buffer @p tx\n\n @param [in] me A sucessfuly initialized state by @ref cmt_io_init\n @return\n - writable memory region (check @ref cmt_buf_t)\n @note memory is valid until @ref cmt_io_fini is called."]
    pub fn cmt_io_get_tx(me: *mut cmt_io_driver_t) -> cmt_buf_t;
}
extern "C" {
    #[doc = " Retrieve the receive buffer @p rx\n\n @param [in] me A sucessfuly initialized state by @ref cmt_io_init\n @return\n - readable memory region (check @ref cmt_buf_t)\n @note memory is valid until @ref cmt_io_fini is called."]
    pub fn cmt_io_get_rx(me: *mut cmt_io_driver_t) -> cmt_buf_t;
}
extern "C" {
    #[doc = " Perform the yield encoded in @p rr.\n\n @param [in] me A sucessfuly initialized state by @ref cmt_io_init\n @param [in,out] rr Request and Reply\n @return\n - 0 on success\n - negative errno code on error"]
    pub fn cmt_io_yield(me: *mut cmt_io_driver_t, rr: *mut cmt_io_yield_t)
        -> ::std::os::raw::c_int;
}
#[doc = "< Bytes in the hash digest"]
pub const CMT_KECCAK_LENGTH: _bindgen_ty_6 = 32;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
#[doc = " Opaque internal keccak state"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union cmt_keccak_state {
    pub b: [u8; 200usize],
    pub q: [u64; 25usize],
}
#[test]
fn bindgen_test_layout_cmt_keccak_state() {
    const UNINIT: ::std::mem::MaybeUninit<cmt_keccak_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmt_keccak_state>(),
        200usize,
        concat!("Size of: ", stringify!(cmt_keccak_state))
    );
    assert_eq!(
        ::std::mem::align_of::<cmt_keccak_state>(),
        8usize,
        concat!("Alignment of ", stringify!(cmt_keccak_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_keccak_state),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).q) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_keccak_state),
            "::",
            stringify!(q)
        )
    );
}
#[doc = " Opaque internal keccak state"]
pub type cmt_keccak_state_t = cmt_keccak_state;
#[doc = " Opaque Keccak state, used to do hash computations, initialize with:\n - @ref cmt_keccak_init\n - @ref CMT_KECCAK_INIT\n - @ref CMT_KECCAK_DECL"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cmt_keccak {
    pub st: cmt_keccak_state_t,
    pub pt: ::std::os::raw::c_int,
    pub rsiz: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cmt_keccak() {
    const UNINIT: ::std::mem::MaybeUninit<cmt_keccak> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmt_keccak>(),
        208usize,
        concat!("Size of: ", stringify!(cmt_keccak))
    );
    assert_eq!(
        ::std::mem::align_of::<cmt_keccak>(),
        8usize,
        concat!("Alignment of ", stringify!(cmt_keccak))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_keccak),
            "::",
            stringify!(st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pt) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_keccak),
            "::",
            stringify!(pt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsiz) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_keccak),
            "::",
            stringify!(rsiz)
        )
    );
}
#[doc = " Opaque Keccak state, used to do hash computations, initialize with:\n - @ref cmt_keccak_init\n - @ref CMT_KECCAK_INIT\n - @ref CMT_KECCAK_DECL"]
pub type cmt_keccak_t = cmt_keccak;
extern "C" {
    #[doc = " Initialize a @ref cmt_keccak_t hasher state.\n\n @param [out] state uninitialized @ref cmt_keccak_t"]
    pub fn cmt_keccak_init(state: *mut cmt_keccak_t);
}
extern "C" {
    #[doc = " Hash @b n bytes of @b data\n\n @param [in,out] state  initialize the hasher state\n @param [in]     length bytes in @b data to process\n @param [in]     data   data to hash"]
    pub fn cmt_keccak_update(
        state: *mut cmt_keccak_t,
        n: usize,
        data: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Finalize the hash calculation from @b state and store it in @b md\n\n @param [in]  state initialize the hasher state (with all data already added to it)\n @param [out] md    32bytes to store the computed hash"]
    pub fn cmt_keccak_final(state: *mut cmt_keccak_t, md: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Hash all @b n bytes of @b data at once\n\n @param [in]  length bytes in @b data to process\n @param [in]  data   data to hash\n @param [out] md     32bytes to store the computed hash\n @return pointer to @b md\n\n Equivalent to:\n @code\n cmt_keccak_t st = CMT_KECCAK_INIT(&st);\n cmt_keccak_update(&st, n, data);\n cmt_keccak_final(&st, md);\n return md;\n @endcode"]
    pub fn cmt_keccak_data(
        length: usize,
        data: *const ::std::os::raw::c_void,
        md: *mut u8,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Compute the function selector from the solidity declaration @p decl\n\n @param [in]  decl   solidity call declaration, without variable names\n @param [out] funsel function selector as described by @ref funsel\n @return A @p funsel value as if defined by @ref CMT_ABI_FUNSEL\n\n Example usage:\n @code\n ...\n uint32_t funsel = cmt_keccak_funsel(\"FunctionCall(address,bytes)\");\n ...\n @endcode"]
    pub fn cmt_keccak_funsel(decl: *const ::std::os::raw::c_char) -> u32;
}
#[doc = "< merkle tree height"]
pub const CMT_MERKLE_MAX_DEPTH: _bindgen_ty_7 = 64;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
#[doc = " Opaque Merkle tree state.\n initialize with: @ref cmt_merkle_init"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmt_merkle_t {
    pub leaf_count: u64,
    pub state: [[u8; 32usize]; 64usize],
    pub zero: *const [::std::os::raw::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_cmt_merkle_t() {
    const UNINIT: ::std::mem::MaybeUninit<cmt_merkle_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmt_merkle_t>(),
        2064usize,
        concat!("Size of: ", stringify!(cmt_merkle_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cmt_merkle_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cmt_merkle_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).leaf_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_merkle_t),
            "::",
            stringify!(leaf_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_merkle_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zero) as usize - ptr as usize },
        2056usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_merkle_t),
            "::",
            stringify!(zero)
        )
    );
}
extern "C" {
    #[doc = " Initialize a @ref cmt_merkle_t tree state.\n\n @param [in] me    uninitialized state"]
    pub fn cmt_merkle_init(me: *mut cmt_merkle_t);
}
extern "C" {
    #[doc = " Finalize a @ref cmt_merkle_t tree state.\n\n @param [in] me    initialized state\n\n @note use of @p me after this call is undefined behavior."]
    pub fn cmt_merkle_fini(me: *mut cmt_merkle_t);
}
extern "C" {
    #[doc = " Load the a @ref cmt_merkle_t tree from a @p file handle.\n\n @param [in] me       either a initialized or uninitialized state\n @param [in] filepath which file to save the merkle state\n @return\n - 0 on success"]
    pub fn cmt_merkle_load(
        me: *mut cmt_merkle_t,
        filepath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Save the a @ref cmt_merkle_t tree to a @p file handle.\n\n @param [in] me       either a initialized or uninitialized state\n @param [in] filepath which file to save the merkle state\n @return\n - 0 on success"]
    pub fn cmt_merkle_save(
        me: *mut cmt_merkle_t,
        filepath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Size in bytes required by merkle state save\n\n @param [in] me     uninitialized state\n @param [in] length size of @p data in bytes\n @param [in] data   array of bytes\n @return\n - size of the array required by @ref cmt_merkle_state_save"]
    pub fn cmt_merkle_max_length() -> usize;
}
extern "C" {
    #[doc = " Append a leaf node\n\n @param [in,out] me initialized state\n @param [in] hash   value of the new leaf\n @return\n - 0        success\n - -ENOBUFS indicates the tree is full"]
    pub fn cmt_merkle_push_back(me: *mut cmt_merkle_t, hash: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compute the keccak-256 hash of @p data and append it as a leaf node\n\n @param [in,out] me     initialized state\n @param [in]     length size of @p data in bytes\n @param [in]     data   array of bytes\n @return\n - 0        success\n - -ENOBUFS indicates that the tree is full"]
    pub fn cmt_merkle_push_back_data(
        me: *mut cmt_merkle_t,
        length: usize,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the root hash of the merkle tree\n\n @param [in]  me   initialized state\n @param [out] root root hash of the merkle tree"]
    pub fn cmt_merkle_get_root_hash(me: *mut cmt_merkle_t, root: *mut u8);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cmt_rollup {
    pub io: [cmt_io_driver; 1usize],
    pub merkle: [cmt_merkle_t; 1usize],
}
#[test]
fn bindgen_test_layout_cmt_rollup() {
    const UNINIT: ::std::mem::MaybeUninit<cmt_rollup> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmt_rollup>(),
        2280usize,
        concat!("Size of: ", stringify!(cmt_rollup))
    );
    assert_eq!(
        ::std::mem::align_of::<cmt_rollup>(),
        8usize,
        concat!("Alignment of ", stringify!(cmt_rollup))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_rollup),
            "::",
            stringify!(io)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).merkle) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_rollup),
            "::",
            stringify!(merkle)
        )
    );
}
pub type cmt_rollup_t = cmt_rollup;
#[doc = " Public struct with the advance state contents"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmt_rollup_advance {
    #[doc = "< the address of the input sender"]
    pub sender: [u8; 20usize],
    #[doc = "< block number of this input"]
    pub block_number: u64,
    #[doc = "< block timestamp of this input UNIX epoch format)"]
    pub block_timestamp: u64,
    #[doc = "< input index (in relation to all inputs ever sent to the DApp)"]
    pub index: u64,
    #[doc = "< length in bytes of the data field"]
    pub length: u32,
    #[doc = "< advance contents"]
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cmt_rollup_advance() {
    const UNINIT: ::std::mem::MaybeUninit<cmt_rollup_advance> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmt_rollup_advance>(),
        64usize,
        concat!("Size of: ", stringify!(cmt_rollup_advance))
    );
    assert_eq!(
        ::std::mem::align_of::<cmt_rollup_advance>(),
        8usize,
        concat!("Alignment of ", stringify!(cmt_rollup_advance))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sender) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_rollup_advance),
            "::",
            stringify!(sender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_number) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_rollup_advance),
            "::",
            stringify!(block_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_timestamp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_rollup_advance),
            "::",
            stringify!(block_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_rollup_advance),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_rollup_advance),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_rollup_advance),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Public struct with the advance state contents"]
pub type cmt_rollup_advance_t = cmt_rollup_advance;
#[doc = " Public struct with the inspect state contents"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmt_rollup_inspect {
    #[doc = "< length in bytes of the data field"]
    pub length: u32,
    #[doc = "< inspect contents"]
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cmt_rollup_inspect() {
    const UNINIT: ::std::mem::MaybeUninit<cmt_rollup_inspect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmt_rollup_inspect>(),
        16usize,
        concat!("Size of: ", stringify!(cmt_rollup_inspect))
    );
    assert_eq!(
        ::std::mem::align_of::<cmt_rollup_inspect>(),
        8usize,
        concat!("Alignment of ", stringify!(cmt_rollup_inspect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_rollup_inspect),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_rollup_inspect),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Public struct with the inspect state contents"]
pub type cmt_rollup_inspect_t = cmt_rollup_inspect;
#[doc = " Public struct with the finish state contents"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmt_rollup_finish {
    pub accept_previous_request: bool,
    pub next_request_type: ::std::os::raw::c_int,
    pub next_request_payload_length: u32,
}
#[test]
fn bindgen_test_layout_cmt_rollup_finish() {
    const UNINIT: ::std::mem::MaybeUninit<cmt_rollup_finish> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmt_rollup_finish>(),
        12usize,
        concat!("Size of: ", stringify!(cmt_rollup_finish))
    );
    assert_eq!(
        ::std::mem::align_of::<cmt_rollup_finish>(),
        4usize,
        concat!("Alignment of ", stringify!(cmt_rollup_finish))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accept_previous_request) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_rollup_finish),
            "::",
            stringify!(accept_previous_request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_request_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_rollup_finish),
            "::",
            stringify!(next_request_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_request_payload_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmt_rollup_finish),
            "::",
            stringify!(next_request_payload_length)
        )
    );
}
#[doc = " Public struct with the finish state contents"]
pub type cmt_rollup_finish_t = cmt_rollup_finish;
extern "C" {
    #[doc = " Initialize a @ref cmt_rollup_t state.\n\n @param [in] me    uninitialized state\n\n - 0 success\n - negative value on error. values from: @ref cmt_rollup_driver_init"]
    pub fn cmt_rollup_init(me: *mut cmt_rollup_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Finalize a @ref cmt_rollup_t statate previously initialized with @ref\n cmt_rollup_init\n\n @param [in] me    initialized state\n\n @note use of @p me after this call is undefined behavior."]
    pub fn cmt_rollup_fini(me: *mut cmt_rollup_t);
}
extern "C" {
    #[doc = " Emit a voucher\n\n @param [in,out] me      initialized cmt_rollup_t instance\n @param [in]     address destination\n @param [in]     n       sizeof @p data in bytes\n @param [in]     data    message contents\n @return\n - 0 success\n - -ENOBUFS no space left in @p me"]
    pub fn cmt_rollup_emit_voucher(
        me: *mut cmt_rollup_t,
        address_length: u32,
        address_data: *const ::std::os::raw::c_void,
        value_length: u32,
        value_data: *const ::std::os::raw::c_void,
        length: u32,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Emit a notice\n\n @param [in,out] me      initialized cmt_rollup_t instance\n @param [in]     n       sizeof @p data in bytes\n @param [in]     data    message contents\n @return\n - 0 success\n - -ENOBUFS no space left in @p me"]
    pub fn cmt_rollup_emit_notice(
        me: *mut cmt_rollup_t,
        length: u32,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Emit a report\n @param [in,out] me      initialized cmt_rollup_t instance\n @param [in]     n       sizeof @p data in bytes\n @param [in]     data    message contents\n @return\n - 0 success\n - -ENOBUFS no space left in @p me"]
    pub fn cmt_rollup_emit_report(
        me: *mut cmt_rollup_t,
        length: u32,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Emit a exception\n @param [in,out] me      initialized cmt_rollup_t instance\n @param [in]     n       sizeof @p data in bytes\n @param [in]     data    message contents\n @return\n - 0 success\n - -ENOBUFS no space left in @p me"]
    pub fn cmt_rollup_emit_exception(
        me: *mut cmt_rollup_t,
        length: u32,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read advance state\n\n @return\n - 0 success\n - negative value on error."]
    pub fn cmt_rollup_read_advance_state(
        me: *mut cmt_rollup_t,
        advance: *mut cmt_rollup_advance_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read inspect state\n\n @return\n - 0 success\n - negative value on error."]
    pub fn cmt_rollup_read_inspect_state(
        me: *mut cmt_rollup_t,
        inspect: *mut cmt_rollup_inspect_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Finish processing of current advance or inspect.\n Waits for and returns the next advance or inspect query when available.\n\n @param [in,out] me      initialized cmt_rollup_t instance\n @param [in,out] finish  initialized cmt_rollup_finish_t instance\n\n @return\n - 0 success\n - negative value on error"]
    pub fn cmt_rollup_finish(
        me: *mut cmt_rollup_t,
        finish: *mut cmt_rollup_finish_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the merkle tree and intermediate state from a file @p path\n @param [in,out] me      initialized cmt_rollup_t instance\n @param [in]     file    path to file (parent directories must exist)"]
    pub fn cmt_rollup_load_merkle(
        me: *mut cmt_rollup_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Store the merkle tree and intermediate state to a file @p path\n\n @param [in,out] me      initialized cmt_rollup_t instance\n @param [in]     file    path to file (parent directories must exist)"]
    pub fn cmt_rollup_save_merkle(
        me: *mut cmt_rollup_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
